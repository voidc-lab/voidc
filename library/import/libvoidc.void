//---------------------------------------------------------------------
//- Copyright (C) 2020-2026 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("libvoidc.void  must be imported into the voidc target only!");

    v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("llvm-c/Core.void");
    v_import("llvm-c/BitReader.void");
    v_import("llvm-c/TargetMachine.void");
    v_import("llvm-c/Transform/PassBuilder.void");
}

{   v_enable_level_01();
    v_enable_level_02();

    //-------------------------------------------------------------
    voidc_clear_unit_buffer();
}


//---------------------------------------------------------------------
export LIBVOIDC_LIMIT_LEVEL_01 = (0x01 : LLVMValueRef);
export LIBVOIDC_LIMIT_LEVEL_02 = (0x02 : LLVMValueRef);
export LIBVOIDC_LIMIT_LEVEL_03 = (0x03 : LLVMValueRef);


//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("level_limit_q", q_ref, q("libvoidc.level_limit"));

    v_add_symbol("enable_03_q", q_ref, q("v_enable_level_03"));

    v_add_symbol("target_triple_q",  q_ref, q("libvoidc.target_triple"));
    v_add_symbol("target_sysroot_q", q_ref, q("libvoidc.target_sysroot"));

    v_add_symbol("bin_suffix_q", q_ref, q("voidc.import_bin_filename_suffix"));
}


//=====================================================================
{   voidc_unit_begin_module("libvoidc_module"); }


//---------------------------------------------------------------------
export
voidc_set_level_limit: (level: LLVMValueRef) ~> void
{
    v_add_constant_q(level_limit_q, v_void_type(), level);
}

//---------------------------------------------------------------------
private
my_import_mainline: () ~> void
{
    level = v_find_constant_value_q(level_limit_q);

    v_import("level-00");
    v_import("level-01");   if (level == LIBVOIDC_LIMIT_LEVEL_01) return;
    v_import("level-02");   if (level == LIBVOIDC_LIMIT_LEVEL_02) return;
    v_import("level-03");
}

//---------------------------------------------------------------------
private
my_enable_mainline: () ~> void
{
    level = v_find_constant_value_q(level_limit_q);

    v_enable_level_01();    if (level == LIBVOIDC_LIMIT_LEVEL_01) return;
    v_enable_level_02();    if (level == LIBVOIDC_LIMIT_LEVEL_02) return;

    f_03: &*(() ~> void) := undef;

    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    if (gctx != vctx) v_target_set_global_ctx(vctx);

    f_03 := (v_find_symbol_value_q(enable_03_q) : *(() ~> void));

    if (gctx != vctx) v_target_set_global_ctx(gctx);

    if (f_03) f_03();  else  return;
}


//---------------------------------------------------------------------
private
clean_header: (aux: *void) ~> void
{
    lctx = (aux: *v_target_local_ctx_t);

    v_target_destroy_local_ctx(lctx);
}

//---------------------------------------------------------------------
export
voidc_make_header: (name: *const char) ~> void
{
    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    if (gctx != vctx)
    {
        level = v_find_constant_value_q(level_limit_q);

        is_win32 = v_find_constant("_WIN32", 0, 0);

        v_target_set_global_ctx(vctx);

        if (level)  v_add_constant_q(level_limit_q, v_void_type(), level);

        my_import_mainline();
        my_enable_mainline();

        filename = v_target_local_ctx_get_filename(v_target_get_voidc_local_ctx());

        lctx = v_target_create_local_ctx(filename, gctx);

        v_add_local_cleaner(clean_header, lctx);

        v_target_set_global_ctx(gctx);

        //----------------------------------------------------------
        #if (v_defined(NDEBUG))   v_add_constant("NDEBUG", v_void_type(), 0);   #endif      //- ?!?!?!?!?

        if (is_win32)   v_add_constant("_WIN32", v_void_type(), 0);

        if (level)  v_add_constant_q(level_limit_q, v_void_type(), level);
    }
    else    //- e.g.  gctx == vctx
    {
        my_import_mainline();
    }

    my_enable_mainline();

    v_set_export_flag(true);
}


//---------------------------------------------------------------------
#if (v_defined(_WIN32))
  _strdup: (*const char) ~> *char;
  alwaysinline strdup: (s: *const char) ~> *char  =  _strdup(s);
#else
  strdup: (*const char) ~> *char;
#endif

free:   (*void) ~> void;

//---------------------------------------------------------------------
export
voidc_set_target_triple: (triple: *const char) ~> void
{
    triple = strdup(triple);

    v_add_constant_q(target_triple_q, void, (triple: LLVMValueRef));        //- Sic!

    v_add_local_cleaner(free, triple);
}

//---------------------------------------------------------------------
export
voidc_set_target_sysroot: (sysroot: *const char) ~> void
{
    v_assert(v_find_constant_value_q(target_triple_q));

    sysroot = strdup(sysroot);

    v_add_constant_q(target_sysroot_q, void, (sysroot: LLVMValueRef));      //- Sic!

    v_add_local_cleaner(free, sysroot);
}

//---------------------------------------------------------------------
export
voidc_make_module: (modname: *const char) ~> void
{
    voidc_guard_target("voidc_make_module  must be called from the voidc target only!");

    my_import_mainline();
    my_enable_mainline();

    //----------------------------------------------------------
    triple: &*const char := 0;

    sizes: &size_t[3] := undef;

    is_win32: &bool := undef;

    data_layout: &LLVMTargetDataRef := undef;

    //----------------------------------------------------------
    if (triple := (v_find_constant_value_q(target_triple_q) : *const char))
    {
        //- Cross-compilation...

        struct FILE;

        popen:   (*const char, *const char) ~> *FILE;
        pclose:  (*FILE) ~> int;
        fprintf: (*FILE, *const char, ...) ~> int;
        fscanf:  (*FILE, *const char, ...) ~> int;
        sprintf: (*char, *const char, ...) ~> int;

        //------------------------------------------------------
        buflen = 1024;

        buffer = v_malloc(char, buflen);
        defer v_free(buffer);

        {   p = popen("mktemp", "r");
            defer pclose(p);

            fscanf(p, "%500s", buffer);
        }

        #if (v_defined(_WIN32))
        {
            cmd = buffer + 512;

            sprintf(cmd, "cygpath -m %s", buffer);

            p = popen(cmd, "r");
            defer pclose(p);

            fscanf(p, "%1000s", buffer);
        }
        #endif

        //------------------------------------------------------
        {   p = popen("bash", "w");
            defer pclose(p);

            fprintf(p, "clang -target %s", triple);

//            if (sysroot = (v_find_constant_value_q(target_sysroot_q) : *const char))
//            {
//                fprintf(p, " --sysroot=%s", sysroot);
//            }

            fprintf(p, " -emit-llvm -c -o %s -x c", buffer);

            source_str =
            """
            int my_size_int  = sizeof(int);
            int my_size_long = sizeof(long);
            int my_size_ptr  = sizeof(void *);

            #ifdef _WIN32
            int my__WIN32 = 1;
            #else
            int my__WIN32 = 0;
            #endif
            """;

            fprintf(p, " - <<HEREDOC\n%s\nHEREDOC\n", source_str);
        }

        //------------------------------------------------------
        {   mb: &LLVMMemoryBufferRef := 0;
            defer LLVMDisposeMemoryBuffer(mb);

            LLVMCreateMemoryBufferWithContentsOfFile(buffer, &mb, 0);

            mod: &LLVMModuleRef := undef;

            LLVMParseBitcodeInContext2(v_target_get_llvm_ctx(), mb, &mod);

            GN = LLVMGetNamedGlobal;
            GI = LLVMGetInitializer;
            ZV = LLVMConstIntGetZExtValue;

            sizes[0] := (ZV(GI(GN(mod, "my_size_int")))  : size_t);
            sizes[1] := (ZV(GI(GN(mod, "my_size_long"))) : size_t);
            sizes[2] := (ZV(GI(GN(mod, "my_size_ptr")))  : size_t);

            is_win32 := (ZV(GI(GN(mod, "my__WIN32"))) != 0);

            data_layout := LLVMGetModuleDataLayout(mod);
        }

        //------------------------------------------------------
        {   p = popen("bash", "w");
            defer pclose(p);

            fprintf(p, "rm %s\n", buffer);
        }
    }
    else
    {
        //- Host-compilation...

        sizes[0] := int.sizeof;
        sizes[1] := long.sizeof;
        sizes[2] := intptr_t.sizeof;

        is_win32 := v_defined(_WIN32);

        data_layout := v_target_get_voidc_data_layout();
    }

    //----------------------------------------------------------
    filename = v_target_local_ctx_get_filename(v_target_get_voidc_local_ctx());

    gctx = v_target_create_global_ctx(sizes[0], sizes[1], sizes[2]);
    lctx = v_target_create_local_ctx(filename, gctx);

    suffix: &*const char := "c-aot";        //- ?

    if (triple)
    {
        sstr = v_make_object(v_std_string_t);

        v_std_string_set(sstr, "c-");

        v_std_string_append(sstr, triple);

        suffix := strdup(v_std_string_get(sstr));

        v_add_local_cleaner(free, suffix);
    }

    v_target_global_ctx_add_constant_value(gctx, bin_suffix_q, (suffix: LLVMValueRef));

    level = v_find_constant_value_q(level_limit_q);

    v_target_set_global_ctx(gctx);

    //----------------------------------------------------------
    v_target_set_data_layout(data_layout);

    //----------------------------------------------------------
    #if (v_defined(NDEBUG))   v_add_constant("NDEBUG", v_void_type(), 0);   #endif      //- ?!?!?!?!?!?

    if (is_win32)   v_add_constant("_WIN32", v_void_type(), 0);

    if (level)  v_add_constant_q(level_limit_q, v_void_type(), level);

    //----------------------------------------------------------
    my_enable_mainline();

    //----------------------------------------------------------
    module = LLVMModuleCreateWithNameInContext(modname, v_target_get_llvm_ctx());

    strlen: (*const char) ~> size_t;

    LLVMSetSourceFileName(module, filename, strlen(filename));

    v_set_module(module);
}


//---------------------------------------------------------------------
export
voidc_emit_module: (filename: *const char) ~> void
{
    module = v_get_module();

    v_finish_module(module);

    //----------------------------------------------------------
    v_verify_module(module);

    //----------------------------------------------------------
    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    v_target_set_global_ctx(vctx);

    //----------------------------------------------------------
    triple: &*const char := 0;

    cpu_name:     &*const char := undef;
    cpu_features: &*const char := undef;

    is_host: &bool := undef;

    if (triple := (v_find_constant_value_q(target_triple_q) : *const char))
    {
        //- Cross-compilation...

        cpu_name     := "generic";          //- ?
        cpu_features := "";                 //- ?

        is_host := false;
    }
    else
    {
        //- Host-compilation...

        triple := LLVMGetDefaultTargetTriple();

        cpu_name     := LLVMGetHostCPUName();
        cpu_features := LLVMGetHostCPUFeatures();

        is_host := true;
    }

    v_target_set_global_ctx(gctx);

    //----------------------------------------------------------
    tr: &LLVMTargetRef := undef;

    LLVMGetTargetFromTriple(triple, &tr, 0);

    target_machine =
        LLVMCreateTargetMachine
        (
            tr,
            triple,
            cpu_name,
            cpu_features,
            LLVMCodeGenLevelDefault,
            LLVMRelocPIC,                   //- WTF !?!
            LLVMCodeModelDefault
        );

    //----------------------------------------------------------
    dl = LLVMCreateTargetDataLayout(target_machine);

    #if (!v_defined(NDEBUG))
    {
        s0 = LLVMCopyStringRepOfTargetData(v_target_get_data_layout());
        s1 = LLVMCopyStringRepOfTargetData(dl);

        strcmp: (*const char, *const char) ~> int;

        v_assert(strcmp(s0, s1) == 0);          //- WTF !?!?!?!?!?!?!?!

        LLVMDisposeMessage(s1);
        LLVMDisposeMessage(s0);
    }
    #endif

    LLVMSetModuleDataLayout(module, dl);
    LLVMSetTarget(module, triple);

    LLVMDisposeTargetData(dl);

    if (is_host)
    {
        LLVMDisposeMessage(cpu_features);
        LLVMDisposeMessage(cpu_name);
        LLVMDisposeMessage(triple);
    }

    //----------------------------------------------------------
    {   opts = LLVMCreatePassBuilderOptions();

        err = LLVMRunPasses(module, "default<O3>", target_machine, opts);
//      err = LLVMRunPasses(module, "disable-builtin<printf>,default<O3>", target_machine, opts);

        if (err)
        {
            msg = LLVMGetErrorMessage(err);

            printf: (*const char, ...) ~> int;

            printf("LLVMRunPasses: %s\n", msg);

            LLVMDisposeErrorMessage(msg);
        }

        LLVMDisposePassBuilderOptions(opts);
    }

    //----------------------------------------------------------
    v_verify_module(module);

    //----------------------------------------------------------
    LLVMTargetMachineEmitToFile(target_machine, module, filename, LLVMObjectFile, 0);

    //----------------------------------------------------------
    LLVMDisposeModule(module);

    LLVMDisposeTargetMachine(target_machine);

    //----------------------------------------------------------
    lctx = v_target_get_local_ctx();

    v_target_set_global_ctx(vctx);

    v_target_destroy_local_ctx(lctx);
    v_target_destroy_global_ctx(gctx);
}


//=====================================================================
{   voidc_unit_end_module(); }


